import { z } from "zod/v4";

/**
 * Zod Schema for the 'users' table.
 * Represents the structure and validation rules for user data.
 */
export const UserSchema = z.object({
  // user_id is typically auto-generated by the database, so it's optional for creation.
  user_id: z.number().int().positive().optional(),
  // Email must be a valid email format and is required.
  email: z.email("Invalid email address").min(1, "Email is required"),
  // password_hash is required; validation for strength would happen before hashing.
  password_hash: z.string().min(1, "Password hash is required"),
  // First name is optional and can be null.
  first_name: z.string().max(100, "First name too long").optional().nullable(),
  // Last name is optional and can be null.
  last_name: z.string().max(100, "Last name too long").optional().nullable(),
  // created_at is typically auto-generated by the database, so it's optional for creation.
  // Using string for datetime as it's often retrieved as ISO string from DB.
  created_at: z.string().datetime().optional().nullable(),
});

/**
 * Zod Schema for the 'events' table.
 * Represents the structure and validation rules for event data.
 */
export const EventSchema = z.object({
  // event_id is typically auto-generated by the database, so it's optional for creation.
  event_id: z.number().int().positive().optional(),
  // Event name is required and has a max length.
  event_name: z
    .string()
    .min(1, "Event name is required")
    .max(255, "Event name too long"),
  // Description is optional and can be null.
  description: z.string().optional().nullable(),
  // event_date is required and must be a valid datetime string.
  event_date: z.date("Invalid event date and time"),
  // Venue is optional and can be null.
  venue: z.string().max(255, "Venue name too long").optional().nullable(),
  // total_tickets is required and must be a positive integer.
  total_tickets: z
    .number()
    .int()
    .positive("Total tickets must be positive")
    .optional(),
  // tickets_sold defaults to 0 and is managed by the database/application logic.
  event_image_url: z.string().nullable().optional(),
  tickets_sold: z
    .number()
    .int()
    .min(0, "Tickets sold cannot be negative")
    .default(0)
    .optional(),
});

/**
 * Zod Schema for the 'tickets' table.
 * Represents the structure and validation rules for individual ticket types within an event.
 */
export const TicketSchema = z.object({
  // ticket_id is typically auto-generated by the database, so it's optional for creation.
  ticket_id: z.number().int().positive().optional(),
  // event_id is required and must be a positive integer, referencing an existing event.
  event_id: z.number().int().positive("Event ID is required"),
  // ticket_type defaults to 'Standard' and is optional for creation.
  ticket_type: z
    .string()
    .max(100, "Ticket type too long")
    .default("Standard")
    .optional(),
  // Price is required and must be a positive number.
  price: z.number().positive("Price must be positive"),
  // quantity_available is required and must be a non-negative integer.
  quantity_available: z
    .number()
    .int()
    .min(0, "Quantity available cannot be negative"),
  // quantity_sold defaults to 0 and is managed by the database/application logic.
  quantity_sold: z
    .number()
    .int()
    .min(0, "Quantity sold cannot be negative")
    .default(0)
    .optional(),
});

/**
 * Zod Schema for the 'orders' table.
 * Represents the structure and validation rules for user orders.
 */
export const OrderSchema = z.object({
  // order_id is typically auto-generated by the database, so it's optional for creation.
  order_id: z.number().int().positive().optional(),
  // user_id is required and must be a positive integer, referencing an existing user.
  user_id: z.number().int().positive("User ID is required"),
  // order_date is typically auto-generated by the database, so it's optional for creation.
  order_date: z.date().optional().nullable(),
  // total_amount is required and must be a positive number.
  total_amount: z.number().positive("Total amount must be positive"),
  // Status defaults to 'Pending' and is managed by the application logic.
  status: z
    .enum(["Pending", "Confirmed", "Cancelled", "Refunded"])
    .default("Pending")
    .optional(),
});

/**
 * Zod Schema for the 'order_items' table.
 * Represents the structure and validation rules for individual items within an order.
 */
export const OrderItemSchema = z.object({
  // order_item_id is typically auto-generated by the database, so it's optional for creation.
  order_item_id: z.number().int().positive().optional(),
  // order_id is required and must be a positive integer, referencing an existing order.
  order_id: z.number().int().positive("Order ID is required"),
  // ticket_id is required and must be a positive integer, referencing an existing ticket type.
  ticket_id: z.number().int().positive("Ticket ID is required"),
  // Quantity is required and must be a positive integer.
  quantity: z.number().int().positive("Quantity must be positive"),
  // purchase_price_per_ticket is required and must be a positive number.
  // This stores the price at the time of purchase for historical accuracy.
  purchase_price_per_ticket: z
    .number()
    .positive("Purchase price must be positive"),
});

// You can also define types directly from the schemas for TypeScript inference
export type User = z.infer<typeof UserSchema>;
export type Event = z.infer<typeof EventSchema>;
export type Ticket = z.infer<typeof TicketSchema>;
export type Order = z.infer<typeof OrderSchema>;
export type OrderItem = z.infer<typeof OrderItemSchema>;
